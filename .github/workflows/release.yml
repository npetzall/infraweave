name: Release (Reusable)

on:
  workflow_call:
    inputs:
      version:
        required: true
        type: string
        description: Version to release (e.g., 1.2.3)
      dry_run:
        required: false
        type: boolean
        default: false
        description: Whether this is a dry run
  workflow_dispatch:
    inputs:
      version:
        required: false
        type: string
        description: Version to release (e.g., 1.2.3)
        default: 0.0.0-manual
      dry_run:
        required: false
        type: boolean
        default: true
        description: Whether this is a dry run
      run_id:
        required: false
        type: string
        description: Workflow run ID to download artifacts from (defaults to current run)

env:
  VERSION: ${{ inputs.version }}
  DRY_RUN: ${{ inputs.dry_run || false }}
  GHCR_REGISTRY: ghcr.io
  GHCR_REPO: ${{ github.repository }}

jobs:
  generate-release-notes:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    outputs:
      notes: ${{ steps.notes.outputs.notes }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate release notes from conventional commits
        id: notes
        env:
          VERSION: ${{ env.VERSION }}
        run: |
          bash .github/scripts/release_generate-notes.sh

  publish-images:
    needs: [generate-release-notes]
    runs-on: ubuntu-latest
    permissions:
      packages: read
      id-token: write
    if: ${{ vars.RELEASE_REGISTRIES != '' && vars.RELEASE_REGISTRIES != '[]' }}
    strategy:
      fail-fast: false
      matrix:
        registry: ${{ fromJson(vars.RELEASE_REGISTRIES || '[]') }}
    steps:
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log into GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.GHCR_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Log into target registry (${{ matrix.registry.name }})
        if: ${{ matrix.registry.auth_type == 'login' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ matrix.registry.registry }}
          username: ${{ secrets[matrix.registry.user_secret] }}
          password: ${{ secrets[matrix.registry.password_secret] }}

      - name: Configure AWS credentials for ${{ matrix.registry.name }} using OIDC
        if: ${{ matrix.registry.auth_type == 'aws' }}
        uses: aws-actions/configure-aws-credentials@v2
        with:
          role-to-assume: arn:aws:iam::${{ secrets[matrix.registry.account_secret] }}:role/${{ secrets[matrix.registry.role_secret] }}
          aws-region: ${{ secrets[matrix.registry.aws_region_secret] }}

      - name: Log into ${{ matrix.registry.name }}
        if: ${{ matrix.registry.auth_type == 'aws' }}
        run: |
          aws ecr-public get-login-password --region ${{ secrets[matrix.registry.aws_region_secret] }} | docker login --username AWS --password-stdin ${{ matrix.registry.registry }}

      - name: Logged into (${{ matrix.registry.name }})
        run: |
          echo "Target registry: ${{ matrix.registry.registry }}"
          echo "Target repository: ${{ matrix.registry.repository }}"

      - name: Copy multi-platform images from GHCR to target registry
        run: |
          DOCKER_IMAGES='${{ vars.DOCKER_IMAGES }}'
          if [ -z "$DOCKER_IMAGES" ] || [ "$DOCKER_IMAGES" = "null" ]; then
            echo "No Docker images configured"
            exit 0
          fi
          
          DRY_RUN="${{ inputs.dry_run }}"
          if [ "$DRY_RUN" = "true" ]; then
            echo "## DRY RUN: Images that would be copied to ${{ matrix.registry.name }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "## Images copied to ${{ matrix.registry.name }}" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "$DOCKER_IMAGES" | jq -r '.[] | .bin' | while read -r IMAGE_NAME; do
            SOURCE_IMAGE="${{ env.GHCR_REGISTRY }}/${{ env.GHCR_REPO }}/${IMAGE_NAME}:${{ env.VERSION }}"
            TARGET_IMAGE="${{ matrix.registry.registry }}/${{ matrix.registry.repository }}/${IMAGE_NAME}:${{ env.VERSION }}"
            
            echo "Copying ${SOURCE_IMAGE} to ${TARGET_IMAGE} (Dry run: $DRY_RUN)" 
            if [ "$DRY_RUN" != "true" ]; then
              docker buildx imagetools create --tag "${TARGET_IMAGE}" "${SOURCE_IMAGE}"
            fi
            echo "- \`${SOURCE_IMAGE}\` â†’ \`${TARGET_IMAGE}\`" >> $GITHUB_STEP_SUMMARY
          done

  publish-wheels:
    needs: [generate-release-notes]
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    steps:
      - name: Download all wheels
        uses: actions/download-artifact@v4
        with:
          path: ./release-wheels
          pattern: wheels-*
          merge-multiple: true
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Collect wheels
        run: |
          mkdir -p dist_collected
          find ./release-wheels -name '*.whl' -exec cp {} dist_collected/ \;
          find ./release-wheels -name '*.tar.gz' -exec cp {} dist_collected/ \;
          echo "Collected wheels:"
          ls -la dist_collected/

      - name: Publish wheels to PyPI
        if: ${{ !inputs.dry_run }}
        uses: pypa/gh-action-pypi-publish@76f52bc884231f62b9a034ebfe128415bbaabdfc
        with:
          packages-dir: dist_collected/

      - name: Dry run - Show what would be published
        if: ${{ inputs.dry_run }}
        run: |
          echo "## DRY RUN: Packages that would be published to PyPI" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          ls -la dist_collected/ >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY

  create-release:
    needs: [generate-release-notes, publish-wheels, publish-images]
    if: ${{ !cancelled() && !failure() }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
    steps:
      - name: Download all binaries
        uses: actions/download-artifact@v4
        with:
          path: ./release-binaries
          pattern: binaries-*
          merge-multiple: true
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Download all wheels
        uses: actions/download-artifact@v4
        with:
          path: ./release-wheels
          pattern: wheels-*
          merge-multiple: true
          run-id: ${{ inputs.run_id || github.run_id }}

      - name: Create GitHub Release
        if: ${{ !inputs.dry_run }}
        run: |
          FILES=$(find ./release-binaries ./release-wheels -type f 2>/dev/null | tr '\n' ' ' || true)
          if [ -z "$FILES" ]; then
            echo "Error: No files to attach to release"
            exit 1
          fi
          gh release create "v${{ env.VERSION }}" \
            --title "Release v${{ env.VERSION }}" \
            --notes "${{ needs.generate-release-notes.outputs.notes }}" \
            $FILES
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Dry run - Show what would be released
        if: ${{ inputs.dry_run }}
        run: |
          # Write release notes to job summary
          echo "## Release Notes (Dry Run)" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ needs.generate-release-notes.outputs.notes }}" >> $GITHUB_STEP_SUMMARY

          RELEASE_INFO="DRY RUN: Would create GitHub release with:\n"
          RELEASE_INFO="${RELEASE_INFO}  Tag: v${{ env.VERSION }}\n"
          RELEASE_INFO="${RELEASE_INFO}  Name: Release v${{ env.VERSION }}\n"
          RELEASE_INFO="${RELEASE_INFO}  Files:\n"
          FILES=$(find ./release-binaries ./release-wheels -type f 2>/dev/null | sort | sed 's/^/    - /' || true)
          RELEASE_INFO="${RELEASE_INFO}${FILES}\n"
          
          echo -e "$RELEASE_INFO"
          echo "---" >> $GITHUB_STEP_SUMMARY
          echo -e "$RELEASE_INFO" >> $GITHUB_STEP_SUMMARY
          
         
